#!/bin/sh

#
# This script creates ZFS pools and dataset compatible with zsys
#

# Layout https://paste.ubuntu.com/p/6p5gSnKwwT/
#
# Steps:
# - Verify that /target is mounted
# - Retrieve fstab
# - unmount /target
# - delete all the partitions but the ESP
# - Create p1 ext4 size 100MB
# - Create p2 zfs bpool 1GB
# - Create p3 zfs rbool 100% remaining
# - Create datasets
# - Create /swapfile on /target
#
# After setup is done leave it mounted to let Ubiquity proceed with installation

set -eu

REQUIREDPKGS="zfsutils-linux"
TARGET="/target"

usage() {
    # Display script usage
    cat<<EOF
Usage: $(basename $0) [COMMAND] [OPTIONS...]
    Prepares a zsys compatible ZFS system.

Commands:
    init		Initialize the pools and datasets
	finalize	Finalize the installation after the system has been installed
Options:
    -h, --help      This help
    -d, --debug     Enable debug mode
EOF
    exit
}

SHORTOPTS="hd"
LONGOPTS="help,debug"

TEMP=$(getopt -o $SHORTOPTS --long $LONGOPTS -- "$@")
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -h|--help)
            usage;;
        -d|--debug)
            set -x
            shift;;
        --)
            shift;
            break;;
        *)
            usage;;
    esac
done

COMMAND=$( echo $1| tr [[:upper:]] [[:lower:]] )

# The entire disk has been formatted with use_device
# There is either one ext4 partition or one ext4 and one ESP
PART="$(grep -w $TARGET /proc/mounts | awk '{print $1}')"
DISK="$(lsblk -lns -o TYPE,PATH $PART| grep disk| awk '{print $2}')"

check_prerequisites() {
    # Check and set requirements to run this script
    #
    # Check and set the requirements to run this test. If any of the
    # requirement is missing the programs exit with error
    #
    # Args:
    #   $@: List of required packages
    #
    # Returns
    #   Exit program is a requirement is not met
    echo "I: Checking system requirements"

	if [ $(id -u) -ne 0 ]; then
		echo "E: Script must be executed as root. Exiting!"
		exit 1
	fi

    for pkg in $@; do
        if ! dpkg-query -W -f'${Status}' $pkg|grep -q "install ok installed" 2>/dev/null; then
            echo "E: $pkg is required and not installed on this system. Exiting!"
            exit 1
        fi
    done

}

prepare_target() {
	target=$1

	if ! grep -qw "$target" /proc/mounts; then
		echo "E: $target is not mounted. Exiting!"
		exit 1
	fi

	# Save fstab generated by partman
	if [ -f "$target/etc/fstab" ]; then
	    echo "I: Saving existing fstab"
		cp "$target/etc/fstab" /tmp/fstab.partman
	else
		echo "W: $target/etc/fstab doesn't exist"
	fi

	umount "$target" || true

	if grep -qw "$target" /proc/mounts; then
		echo "E: Failed to unmount $TARGET. Exiting!"
		exit 1
	fi
}

format_disk() {
	disk=$1
	partgrub=$2
	partbpool=$3
	partrpool=$4
	partext=$(( $partgrub + 1 ))

	echo "I: Formatting disk $disk with partitions grub:$partgrub ext:$partext bpool:$partbpool rpool:$partrpool"

	start=$(sfdisk -l ${disk}|grep ^${disk}${partgrub}|awk '{print $2}')
	# Partition hard drive
	# TODO: retrieve start of sda1 or 2 and reuse it instead of 2048
	sfdisk $disk<<EOF
${disk}${partgrub}  : start=        $start, size=    50M, type=83, bootable
${disk}${partext}   :                                   type=5
${disk}${partbpool} :                     size=     2G, type=a5
${disk}${partrpool} :                                   type=a5
EOF

	partprobe $disk
}

init_zfs() {
	target=$1
	partbpool=$2
	partrpool=$3

	echo "I: Initializing ZFS"
	# Now we can create the pools and dataset
	UUID_ORIG=$(head -100 /dev/urandom | tr -dc 'a-z0-9' |head -c6)

	# Pools
	# rpool
	zpool create -f \
		-o ashift=12 \
		-O compression=lz4 \
		-O acltype=posixacl \
		-O xattr=sa \
		-O relatime=on \
		-O normalization=formD \
		-O mountpoint=/ \
		-O canmount=off \
		-O dnodesize=auto \
		-O sync=disabled \
		-O mountpoint=/ -R $target rpool ${partrpool}

	# bpool
	zpool create -f \
		-o version=28 \
		-o ashift=12 \
		-d \
		-O xattr=sa \
		-O acltype=posixacl \
		-O relatime=on \
		-O normalization=formD \
		-O mountpoint=/ \
		-O canmount=off \
		-O devices=off \
		-O mountpoint=/boot -R $target bpool ${partbpool}

	# Root and boot dataset
	zfs create rpool/ROOT -o canmount=off -o mountpoint=none
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG} -o mountpoint=/
	zfs create bpool/BOOT -o canmount=off -o mountpoint=none
	zfs create bpool/BOOT/ubuntu_${UUID_ORIG} -o mountpoint=/boot

	# System dataset
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var -o canmount=off
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/lib
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/lib/AccountServices
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/lib/apt
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/lib/dpkg
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/lib/NetworkManager

	# Desktop specific system dataset
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/srv
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/usr -o canmount=off
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/usr/local
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/games
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/log
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/mail
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/snap
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/spool
	zfs create rpool/ROOT/ubuntu_${UUID_ORIG}/var/www

	# USERDATA datasets
	# Dataset associated to the user are created by the installer.
	zfs create rpool/USERDATA -o canmount=off -o mountpoint=/

	# Set zsys properties
	zfs set  org.zsys:bootfs='yes' rpool/ROOT/ubuntu_${UUID_ORIG}
	zfs set  org.zsys:last-used=$(date +%s) rpool/ROOT/ubuntu_${UUID_ORIG}
	zfs set  org.zsys:bootfs='no'  rpool/ROOT/ubuntu_${UUID_ORIG}/srv
	zfs set  org.zsys:bootfs='no'  rpool/ROOT/ubuntu_${UUID_ORIG}/usr
	zfs set  org.zsys:bootfs='no'  rpool/ROOT/ubuntu_${UUID_ORIG}/var
}

move_user () {
	# $1 target
	# $2 username
	# $3 userhome
	# $4 uuid
	target=$1
	user=$2
	userhome=$3
	uuid=$4

	echo "I: Creating user $user with home $userhome"
	mv $target/$userhome $target/tmp/home/$user
	zfs create rpool/USERDATA/${user}_${uuid} -o canmount=on -o mountpoint=$userhome
	chown $(chroot $target id -u $user):$(chroot $target id -g $user) $target/$userhome
	rsync -a $target/tmp/home/$user/ $target/$userhome
	bootfsdataset=$(grep "\s$target\s" /proc/mounts | awk '{ print $1 }')
	zfs set org.zsys:bootfs-datasets=$bootfsdataset rpool/USERDATA/${user}_${UUID_ORIG}
}

init_grub() {
	target=$1
	partgrub=$2

	echo "I: Creating grub partition $partgrub"
	# Finalize grub directory
	mkdir -p $target/boot/grub
	mke2fs -F -t ext4 $partgrub
	mount -t ext4 $partgrub $target/boot/grub
}

check_prerequisites $REQUIREDPKGS

echo "I: Running $(basename $0) $COMMAND"

if [ -z "$COMMAND" ]; then
	echo "E: $COMMAND is mandatory. Exiting!"
	exit 1
elif [ "$COMMAND" = "init" ]; then
	PARTGRUB=$(lsblk -n -o TYPE $DISK|grep ^part| wc -l)
	PARTBPOOL=5
	PARTRPOOL=6

	# Swap files are not supported on ZFS, we use a ZFS volume instead
	SWAPFILE="$(grep -w $TARGET /proc/swaps |awk '{print $1}')"
	SWAPSIZE=0
	SWAPDISABLED=0

	# Disable swap
	if [ -n "$SWAPFILE" ]; then
		SWAPSIZE=$(stat -c%s $SWAPFILE)
		echo "I: Found swapfile with size ${SWAPSIZE}. Disabling"
		swapoff $SWAPFILE
	fi

	prepare_target $TARGET
	format_disk $DISK $PARTGRUB $PARTBPOOL $PARTRPOOL
	init_zfs $TARGET ${DISK}${PARTBPOOL} ${DISK}${PARTRPOOL}
	init_grub $TARGET ${DISK}${PARTGRUB}

	# Generate fstab
	# $TARGET/etc has been destroyed by the creation of the zfs partitition
	# Recreate it
	mkdir -p $TARGET/etc
	if [ -f /tmp/fstab.partman ]; then
		echo "I: Creating fstab"
		grep -Ev '\s/\s|/swapfile' /tmp/fstab.partman > "$TARGET/etc/fstab"
	fi
	grubuuid=$(blkid -s UUID -o value ${DISK}${PARTGRUB})
	echo "UUID=${grubuuid}\t/boot/grub\text4\terrors=remount-ro\t0\t1" >> "$TARGET/etc/fstab"

	# Recreate swap file if there was one
	if [ -n "$SWAPFILE" ]; then
		# Convert to MiB to align the size on the size of a block
		volsize=$(( $SWAPSIZE / 1024 / 1024 ))
		echo "I: Creating swapfile with size ${volsize}MiB"
		zfs create -V ${volsize}M -b $(getconf PAGESIZE) -o compression=zle \
			-o logbias=throughput -o sync=always \
			-o primarycache=metadata -o secondarycache=none \
			rpool/swap

		mkswap -f /dev/zvol/rpool/swap
		echo "/dev/zvol/rpool/swap\tnone\tswap\tdiscard\t0\t0" >> $TARGET/etc/fstab
		swapon -av
	fi

elif [ "$COMMAND" = "finalize" ]; then
	# Install zfs in target
	# NOTE:
	# The code below can be removed once zfs is seeded on desktop images
	#
	# We need network up at this point and resolv.conf
	mount -o bind /dev $TARGET/dev
	mount -o bind /proc $TARGET/proc
	mount -o bind /run $TARGET/run
	mount -o bind /sys $TARGET/sys
	echo "I: Installing missing packages in $TARGET"
	chroot $TARGET apt -qy install zfsutils-linux zfs-initramfs
	umount $TARGET/dev || true
	umount $TARGET/proc || true
	umount $TARGET/run || true
	umount $TARGET/sys || true

	# Activate zfs generator.
	# After enabling the generator we should run zfs set canmount=on DATASET
	# in the chroot for one dataset of each pool to refresh the zfs cache.
	echo "I: Activating zfs generator"
	mkdir -p $TARGET/etc/zfs/zfs-list.cache
	touch $TARGET/etc/zfs/zfs-list.cache/bpool $TARGET/etc/zfs/zfs-list.cache/rpool
	ln -s /usr/lib/zfs-linux/zed.d/history_event-zfs-list-cacher.sh $TARGET/etc/zfs/zed.d

	# Handle userdata
	UUID_ORIG=$(head -100 /dev/urandom | tr -dc 'a-z0-9' |head -c6)
	mkdir -p $TARGET/tmp/home
	for user in $(ls $TARGET/home/); do
		move_user $TARGET $user /home/$user $UUID_ORIG
	done

	move_user $TARGET root /root $UUID_ORIG
else
	echo "E: Unknown command: $COMMAND"
	exit 1
fi
